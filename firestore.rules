
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Function to check if the user is an Admin
    function isAdmin() {
      // UID for the admin user
      return request.auth.uid == 'DP9s4PczVeOYuzRX7bznXe0Q1x03';
    }

    // Rules for the 'users' collection
    match /users/{userId} {
      // Allow users to create their own profile
      allow create: if request.auth.uid == userId;
      // Allow authenticated users to read profiles (e.g., for names, roles)
      // Allow admins to read any user profile
      // Allow teachers to read student profiles if they are in the same group
      allow read: if request.auth != null; // General read access for logged-in users for now
      // Allow users to update their own profile, admins to update any
      allow update: if request.auth.uid == userId || isAdmin();
      // Allow admins to delete users (cautiously)
      allow delete: if isAdmin();
    }

    // Rules for 'departments' and its subcollections
    match /departments/{departmentId} {
      allow read: if request.auth != null;
      allow write: if isAdmin(); // Create, Update, Delete

      match /years/{yearId} {
        allow read: if request.auth != null;
        allow write: if isAdmin();

        match /specialities/{specialityId} {
          allow read: if request.auth != null;
          allow write: if isAdmin();

          match /groups/{groupId} {
            allow read: if request.auth != null;
            allow write: if isAdmin();

            // Schedule subcollection within each group
            // This specific path rule is fine, but the collectionGroup rule below is more general for admin reads.
            match /schedule/{scheduleId} {
              allow read: if isAdmin() ||
                           request.auth.uid == resource.data.teacherId ||
                           (exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
                           get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'Student' &&
                           get(/databases/$(database)/documents/users/$(request.auth.uid)).data.assignedGroupId == resource.data.groupId);

              allow write: if isAdmin() || request.auth.uid == resource.data.teacherId; // Admin or assigned teacher can write
              allow delete: if isAdmin() || request.auth.uid == resource.data.teacherId;
            }
          }
        }
      }
    }

    // Explicit rule for 'schedule' collection group for admin reads
    // This helps with collectionGroup queries made by admins.
    match /{path=**}/schedule/{scheduleDocId} {
      allow read: if isAdmin();
      // Note: Write access to 'schedule' via collectionGroup is generally not recommended
      // unless very specific conditions are met, as it bypasses parent document checks.
      // Writes are handled by the more specific path rule above.
    }

    // Rules for the 'attendances' collection
    match /attendances/{attendanceId} {
      allow read: if isAdmin() ||
                     request.auth.uid == resource.data.teacherId ||
                     request.auth.uid == resource.data.studentId;
      allow create, update: if isAdmin() || request.auth.uid == resource.data.teacherId;
      allow delete: if isAdmin();
    }

    // Allow read access to the 'config/userRoles' document for all authenticated users
    match /config/userRoles {
      allow read: if request.auth != null;
      allow write: if isAdmin(); // Only admins can write roles
    }
  }
}
